02/01/26  -  13:03

It migth be a little late to come tyothis conclusion but what i understand from the spaceshooter code that we wrote in class after looking at
is is that none of the classes ever actually load anything. They just define the logic that will be used when the assets are loaded. The actual loading of the assets and spesifics are done is done in the main GameElements class.

So im assuming thats what i should do, make classes that use each other and so ill make a small update and draw method for each of my GameStates in GameElements and then call the methods from there.
And also a reste method because ive changed my mind about how the game will function.

-------------The Game----------------
First youll start off in the menu where you will have 4 options

Play Game
High Scores
Intstuctions
Quit

- If you choose Play Game youll be taken to a battle screen where you will have to fight off waves of enemies. With cards or health that you can upgrade between waves. (Maybe add new unlockable cards if there is time)
Every wave will get harder and harder until you die. Once you die it will show up an overlay that shows what youve accomplished.
Then it will reset all your progress, save it to the HighScore and take you back to the main menu. Where you can restart and try to beat your high score.

- If you choose High Scores youll be taken to a screen that shows your high scores.

- If you choose Instructions youll be taken to a screen that shows you how to play the game. 

- If you choose Quit the game will close.

-------------The Game END----------------



It will consist of the following GameStates:
MenuState
BattleState --> Play game button

??LevelUpState --> (Still unsure if i should add this because it might cause problems with having to change things in the middle of the batlle still running)??

HighScoreState--> High Scores button
InstructionsState --> instructions button
QuitState --> Quit button


MenuState will handle the its buttons (Play, Highscore, Instructions, Quit) and its background.

BattleState will handle the actual game logic and drawing of the game.

=============================================================================================================================================
BRAKE AT 13:37 || BACK AT 16:46
=============================================================================================================================================

Im going to make everything bit by bit. Today ill make the MenuState with its buttons and background.

-------------17:02----------------
I have come to a sligth stop because there is something i dont quite understand about why the gamestates are updated and drawn in Game1 instead of just in GameElements class which to me seems way more sensible.

-?- My first assuption was that its because if i update them in the GameElements and then call the update method in Game1 like this 


        protected override void Update(GameTime gameTime)
        {
            // Escape key exits the game
            if (GamePad.GetState(PlayerIndex.One).Buttons.Back == ButtonState.Pressed || Keyboard.GetState().IsKeyDown(Keys.Escape))
                Exit();

            GameElements.Update[Whatever state](gameTime);

            base.Update(gameTime);
        }

That it would be inneficient because its updating all the gamestates even if they are not active. But then i realized that i could just put that same swich case statment into GameElements something like this:

            switch (GameState)
            {
                case Menu:
                    Menu_UpdateGE(gameTime);
                    break;

                case Play:
                    Play_UpdateGE(gameTime);
                    break;

                case Instructions:
                    Intstructions_Update(gameTime);
                    break;

                case HighScore:
                    HighScore_UpdateGE(gameTime);
                    break;

                case Quit:
                    this.Exit();
                    break;
            }
        }


And make a single Main_Update method in GameElements that would only update the active gamestate and place that into GameElements like this.

        protected override void Update(GameTime gameTime)
        {
            // Escape key exits the game
            if (GamePad.GetState(PlayerIndex.One).Buttons.Back == ButtonState.Pressed || Keyboard.GetState().IsKeyDown(Keys.Escape))
                Exit();

            GameElements.Main_Update(gameTime);

            base.Update(gameTime);
        }

Then it would only update the active gamestate. So im not sure why its done the way it is in Spaceshooter. But ill go research it and try and find an aswer.

=============================================================================================================================================
REASERCH AT 17:16 || BACK AT 17:28
=============================================================================================================================================

I looked into it and found no real reason why its done that way in Spaceshooter. So im going to go ahead and implement the gamestates update and draw methods into GameElements instead of Game1.

The main reason against it is that i lose controll over "handling framework-specific operations like Exit()"
But i have already stumbled onto a solution for that by just calling Environment.Exit(0) via my Button class in a previous version of this project.

So im going to go ahead and implement it that way.


-------------17:36----------------

Ive found another ting that id dont fully understand yet. Its about how the GameStates are defined. On a previous project i made i defined the gamestates as const ints like this:

        public const int MENU = 0, LvlSelect = 1, BtlGround1 = 2, BtlGround2 = 3, BtlGround3 = 4, BtlGround4 = 5, HIGHSCORE = 6;
        private int gameState = MENU; // Current game state


While in Spaceshooter they are defined as an enum like this:

        public enum State { Menu, Run, HighScore, Quit };
        public static State currentState;

=============================================================================================================================================
REASERCH AT 17:44 || BACK AT 17:51
=============================================================================================================================================

After looking into it i found that using an enum is the better way to go about it. 
Primarily because of:

"Type Safety" meaning that you cant assign any random int value 
to the gameState variable. You can only assign the values defined in the enum.

"Better tooling support" mainly mentioning (IntelliSense, refactoring) meaning that when you type gameState. the IDE will show you the possible values from the enum.

"Standard practice in professional C# game development" Meaning that its the more commonly used method in the industry. Making me look more professional.

So im going to go ahead and implement the gamestates as an enum instead of const ints.


-------------18:11----------------

Ive implemented the gamestates as an enum and moved the update and draw methods to GameElements.

-------------19:31----------------

Ive come to a crossroad. I have two choices on how i want to load my button textures. this is the main one that im thinking about:

        `[up in the void]`
        private static Texture2D _menuStartTexture;



        public static void LoadContentGE(ContentManager contentManager, GameWindow window)
        {
            _menuStartTexture = contentManager.Load<Texture2D>("images/Menu/start");
        }

        public static State Menu_UpdateGE(GameTime gameTime)
        {
            Button playButton = new Button(_menuStartTexture, 640 - 100, 100, 200, 50, () => currentState = State.Play, Color.White, Color.Green);
        }

and then draw it like normal. But this makes it so that ill have to make all my buttons as static variables up in the void. Making things look crouded and messy. And i have anopther
option that is a little worse but simpler and shorter:

        public static void LoadContentGE(ContentManager contentManager, GameWindow window)
        {
            content = contentManager;
        }


but in turn makes it a little worse due to these reasons as noted by AI:

•	Static state: Makes testing harder and can cause issues if you ever need multiple game instances
•	Tight coupling: GameElements now depends on ContentManager existing globally
•	Thread safety: Not thread-safe if accessed from multiple threads (unlikely in XNA games, but still worth noting) 

So i think im going to go with the first option even if it makes things a little messier.


-------------19:44----------------

Ok im a little annoyed because i cant draw it now and i think i have to move everything back up to loadcontent in GameElemnts because i cant access the button. I wanted to have everything well spread out
but i guess ill have to put all the button definitions up in the void. and also make the LoadContentGE method a little bigger. But oh well.

-------------20:20----------------

w wrote this code:
        public static Button buttons;
        public static Button playButton;


        public static void LoadContentGE(ContentManager contentManager, GameWindow window)
        {
            playButton = new Button(contentManager.Load<Texture2D>("images/menu/start"), 640 - 200 / 2, 100, 200, 50, () => currentState = State.Play, Color.White, Color.Green);
        }


        public static State Menu_UpdateGE(GameTime gameTime)
        {
            MouseState mouse = Mouse.GetState();
            playButton.Update(mouse);

            // Menu update logic for game elements can be added here
            Debug.WriteLine("In Menu Update GE");
            return State.Menu;
        }



        public static void Menu_DrawGE(SpriteBatch spriteBatch)
        {
            playButton.Draw(spriteBatch);
            // Drawing logic for game elements can be added here
        }


Then i asked AI if there was any issues with the code and it said:

Summary of Issues
1.	❌ Unused variables (menuButtons list, buttons field)  -- Ignore this/I was half way through implementing a button list
2.	❌ Not scalable (individual button fields instead of collections) 

3.	❌ Inconsistent return types (State vs void) -- I tride to make it resemble the one that we had in Spaceshooter but i guess im not supposed to anymore.
I just tested removeing all the "public static State" and made it "public static void" and it didnt seem to effect anything:

4.	⚠️ Magic numbers (hardcoded coordinates) -- 640 - 200 / 2, 100, 200, 50 i sued these to position my buttons but i could use variables instead to make it cleaner.

5.	⚠️ No centralized button management per state -- As i mentiond i was half way through implementing a button list to manage all buttons in a single collection.
So as for now everything looks like it can easily be perfectly optimized.

-------------20:45----------------

Actually ive decided to keep the magic numvbers for now because its easier to visualize where the buttons will be placed on the screen. and also i 
have no clue how to do it without clogging up the code and making it messy. So ill keep it like this for now.

-------------21:21----------------

Im ending it here for today. Ive implemented the MenuState with all working buttons that take you to the seperate gamestates. Im a little nervouse about
the lack of classes, inheritence and polymorphism but i think ill be able to fix that when i start implementing the BattleState.
Because thats where most of the game logic will be. alongside the card system that ill have to implement. 

Im honsetly really scared about the fact that grade wise this is not going to be the most impressive project. 
But im going to try my best to make it as good as possible ot add classes and stuff where i can. Without making things stupid.

___TOMORROW___
Ill have to implement the background for all the GameStates and if i have time i migth throw in and fix Highscore since its already premade for us.






02/02/26  -  17:39

Im gonna impliment the background for all the gamestates today and if i have time ill fix highscore. 

Im going to start by taking in all the stuff from my other project GameGameGame that i understand and try and implimenty it here but have only the logic in background
and loading, drawing and updating in GameElements since thats what we did in SpaceShooter.


-------------18:04----------------

Ive asked AI why its better to have the loading, updating and drawing in GameElements instead of in each gamestate class and then got the asnwer i was expecting but also
i asked it about the code that i used prevoiusly:

using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework.Graphics;
using System;

namespace GameGameGame
{
    /// <summary>
    /// Loads and displays backgrounds for different game states
    /// 
    /// Supports both animated and static backgrounds - automatically loads the right textures when the game state changes
    /// </summary>
    internal class Backgrounds : Objects
    {
        //initializes what its gonna use
        private ContentManager content;
        private GameWindow window;


        // Used to detect when game state changes so we can reload textures
        private int currentGameState = -1; // Start with an invalid value




        public Backgrounds(ContentManager content, GameWindow window) : base()
        {
            this.content = content;
            this.window = window;
            this.destinationRectangle = new Rectangle(0, 0, window.ClientBounds.Width, window.ClientBounds.Height);
        }





        public void UpdateWithState(GameTime gameTime, int gameState)
        {
            // If we switched to a different game state, load new textures
            if (gameState != currentGameState)
            {
                LoadTexturesForState(gameState);
                currentGameState = gameState;
                ResetAnimation();
            }

            // Update size in case window was resized
            destinationRectangle = new Rectangle(0, 0, window.ClientBounds.Width, window.ClientBounds.Height);

            base.Update(gameTime);
        }





        // Load the right background textures for each game state
        private void LoadTexturesForState(int state)
        {
            if (state == GameStateManager.MENU)
            {
                textures = new Texture2D[]
                {
                    content.Load<Texture2D>("images/Menu/bg1"),
                    content.Load<Texture2D>("images/Menu/bg2"),
                    content.Load<Texture2D>("images/Menu/bg3")
                };
            }


            else if (state == GameStateManager.LvlSelect)
            {
                textures = new Texture2D[]
                {
                    content.Load<Texture2D>("images/LvlSelect/Map")
                };
            }


            else if (state == GameStateManager.BtlGround1)
            {
                textures = new Texture2D[]
                {
                    content.Load<Texture2D>("images/BattleGroundSprites/BattleGround1/Battleground_BG1")
                };
            }


            else if (state == GameStateManager.BtlGround2)
            {
                textures = new Texture2D[]
                {
                    content.Load<Texture2D>("images/BattleGroundSprites/BattleGround2/Reze")
                };
            }


            else if (state == GameStateManager.BtlGround3)
            {
                textures = new Texture2D[]
                {
                    content.Load<Texture2D>("images/BattleGrounds/BattleGround3/bg1")
                };
            }


            else if (state == GameStateManager.BtlGround4)
            {
                textures = new Texture2D[]
                {
                    content.Load<Texture2D>("images/BattleGrounds/BattleGround4/bg1")
                };
            }


            else if (state == GameStateManager.HIGHSCORE)
            {
                textures = new Texture2D[]
                {
                    content.Load<Texture2D>("images/HighScore/bg1")
                };
            }
        }
    }
}


It said that it was basically doing too much as a class and braking the single responsibility principle by:

Managing texture loading/unloading (content management)
Handling game state changes
Animation logic (implied by ResetAnimation())
Window resizing
It's essentially a mini-game-manager for backgrounds


It also has memory leaks because everytime i swich gamestates i create a new array of textures 
without disposing the old ones even though its cached even though the same asset won't be reloaded from disk.
So im keeping old useless textures in memory that i dont need anymore.


Its also tightly coupled to the GameStateManager because it directly references game state constants, making it inflexible and it suggseted 
that what if i want to:

Use the same background for multiple states?
Randomly select from multiple backgrounds for a state?
Dynamically load backgrounds based on player progression?

Which i do want to do a little bit of, mainly that i want to randomly select from multiple backgrounds for a state.


And it also gave me a few suggestions on how to do it better, and the one that caugth my eye was this one with JSON-Based:

        // backgrounds.json
        [
          {
            "id": "main_menu",
            "textures": ["images/Menu/bg1", "images/Menu/bg2", "images/Menu/bg3"],
            "animationSpeed": 0.5,
            "states": [0]  // GameStateManager.MENU
          },
          {
            "id": "battle_ground_1", 
            "textures": ["images/BattleGroundSprites/BattleGround1/Battleground_BG1"],
            "states": [2]  // GameStateManager.BtlGround1
          }
        ]

It looks interesting since ive never used it before and its also said to be the most professional way to do it. So im going to try and implement it that way.

AI says its basically better in every way other than it adds some complexity by requiring JSON parsing and data management and also is sligthly slower. 
But i think its worth it.

I stumbled across this video that shows how to implement JSON to save and load stats and stuff which i migth use:
https://www.youtube.com/watch?v=gYksT0d_xLM 


This video is what shows me how to use JSON:
https://www.youtube.com/watch?v=iiADhChRriM&t=170s
Its in java script but it still helped me understand what JSON is and how to build it.

This video shows how to practuiacally use it in monogame C# at about 1 hour and 10 muinets in the video:
https://www.youtube.com/watch?v=fdbGz20q8yk  (Timestamp: 1:10:18) 


=============================================================================================================================================
BRAKE AT 19:55 || BACK AT 21:10
=============================================================================================================================================

Ok before i took the brake i looked into JSON and found out that using record is just better apperantly
but again i have almost no clue how to use it. and when i asked AI to clerify it i didnt understand it any better.

But what im worried about is the upgrade menu or the chaning of anything in the middle of the battle.
Like a new background for a new wave or something. But its so private almost annoyinly so that i cant 
figure out how to do it.

https://www.youtube.com/watch?v=NsLXQQAsYSk

This video dose a grate job on explaining records and how to use it. It also somewhat putts my mind at ease 
about using it for my backgrounds. because my backgound images are in an array and from what i understand 
by using the "with" keyword i can just change the array to a new one with new images whenever i want.
And i think ill also be able to replace it with any random background if i set it up right. with a randomizer.


-------------23:01----------------

Im tired and realized that im not going to be able to implement JSON at all since its so stupidly complex
for me to understand right now. So ill just go and do it the normal boring blocky way that i understand.

and its made for long term projects so its not really suited for a small project like this anyway.

-------------23:13----------------
I was looking at ways to make the code that i showed on line 285-404 more efficeint and just better in general
and came across Dictionary. The AI suggested this as an example

public class BackgroundDefinition
{
    public string[] TexturePaths { get; set; }
    public bool IsAnimated { get; set; }
    public float FrameDuration { get; set; } = 0.1f;
}

// In your main game class or a config loader:
private Dictionary<int, BackgroundDefinition> _backgroundDefinitions;

private void LoadBackgroundDefinitions()
{
    _backgroundDefinitions = new Dictionary<int, BackgroundDefinition>
    {
        { 
            GameStateManager.MENU, 
            new BackgroundDefinition 
            { 
                TexturePaths = new[] { "images/Menu/bg1", "images/Menu/bg2", "images/Menu/bg3" },
                IsAnimated = true,
                FrameDuration = 0.15f
            }
        },
        {
            GameStateManager.LvlSelect,
            new BackgroundDefinition
            {
                TexturePaths = new[] { "images/LvlSelect/Map" },
                IsAnimated = false
            }
        }
        // ... etc
    };
}


And as understand it, its just an inventory you can go in and out of whenever ou want

-------------00:47----------------

Done with the backgrounds im a bit pissed off about how long it took me to implement them in an effective manner as well as 
the amount of research i wasted reading about JSON and records.

My main goal was acheeved tho so im happy about that.

___TOMORROW___
Ill begin on the instructions state and highscore state, and set the ground for possibele currency and upgrade systems in the battlestate. If  i
end up on the optimistic side tomorrow.





03/02/26  -  20:19

So the moment i went back to double chak what i did recently with the backgrounds i realized that i made a mistake.
But i managed to fix it quickly enough.

Also realised that i made another mistake i think. regardless of what is going on the classes are never supposed to holds the logic for it
like:

background = new Background(content.Load<Texture2D>("images/Menu/background"), window);
or loading assests wisch is a mistake so even if it will look ugly i think ill have to put it into GameElements


New problem. i just checked stackoverflow and found out that havin a "God Class" That dose everything is a bad idea. And what
we did in Spaceshooter is exactly that. When i asked AI about it it said that its basically and organised mess and teaches you to be a bad
programmer.

Now im realliy stessing because i wnat ot do it well instead of just rushing through it and making a mess. But im very time limited Right now.


Im way too deep into this project to start over so now im low key pissed because why teach us this if its bad practice.
very very bad practice.

But im way too deep into this project to start over so now which makes me even angryer.

So now ill just have to keep going and try and make it as good as possible.


-------------21:24----------------
So now ill just follow the example left by spaceshooter and try and make it as good as possible. by continuing to move all the information 
about positions into GameElements and just have the classes hold the logic for now.


I realized that i need to plan out my ClassStructure before i start implimenting anything else. Because i have no clue how im going to 
impliment them properly without making things difficult later on


Ive made GameObjects and it will have the absolute most base things that every class that comes after will have:

- Texture
- Position


-------------21:50----------------
Actually ill come back to this later. Its late and im tired. So ill just do the simpler Instructions and Highscore states now.



-------------00:02----------------
Ive implemented the InstructionsState and HighScoreState with working backgrounds and buttons to go back to the menu. And its all fuunctioning correctly.

Though i cant say im verry happy with the God Class still. Among the other things like the lack of inheritence and polymorphism. 
But ill try and fix that when i start implementing the BattleState becasuse there is not yet much to inherit from or polymorph.

And i still dont understand why you have to start a compleatly new state to do the writing and stuff for highscore. 
And im also aware that this code is probably horribley oprimized but i genuinely have no time to fix it now. I know im starting 
instences of stuff that i never use again and stuff like that. And i think the backgrounds are probaly loaded multiple times even if they are the same.

but i have no time to fix it and no clue where to start. So ill just leave it as is. 

___TOMORROW___
Ill start with designing the class and inheritence structure for the Play and the card system. If i have time ill start implementing it as well.
But i have to remember 
good programming is 90% planning and 10% actual coding. So ill take my time to plan it out properly.



06/02/26 -  18:11

Bad news 

ive wasted 3 days doing nothing meaningful.



12/02/26 - 22:20
Bad bad bad 
Im back again a week later and i have done nothing.

But ive come up with a very simple way to implement the battle state and the card system without making things too complex or messy.

Basically the buttons allow me to make an action when i click on them. 
So i can just make a button for each card and then when i click on the card it will do the action of the card.

Ill have them in a list and then when i click on the card the one that i click on will do its action and then be 
removed from the hand and replaced with a new random card from the card assortment.

Its definitely
easier said than done because i have no clue how to actually make
the cards do damage other than just putting a DamageEnemy() method in
the action part and hoping that works. But i have a feeling that it wont be that simple but i think its still possible to acheeve it
and get it done in time.

___TOMORROW___
Tell Tatiana that i have decided to kinda restart ish with this
Check in with her about the new plan and see if she is ok with it
Start with the card system and try to get a basic version of it working with just one card and then build from there.

^^^^T-8 days until the D-day^^^^