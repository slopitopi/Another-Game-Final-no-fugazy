02/01/26  -  13:03

It migth be a little late to come tyothis conclusion but what i understand from the spaceshooter code that we wrote in class after looking at
is is that none of the classes ever actually load anything. They just define the logic that will be used when the assets are loaded. The actual loading of the assets and spesifics are done is done in the main GameElements class.

So im assuming thats what i should do, make classes that use each other and so ill make a small update and draw method for each of my GameStates in GameElements and then call the methods from there.
And also a reste method because ive changed my mind about how the game will function.

-------------The Game----------------
First youll start off in the menu where you will have 4 options

Play Game
High Scores
Intstuctions
Quit

- If you choose Play Game youll be taken to a battle screen where you will have to fight off waves of enemies. With cards or health that you can upgrade between waves. (Maybe add new unlockable cards if there is time)
Every wave will get harder and harder until you die. Once you die it will show up an overlay that shows what youve accomplished.
Then it will reset all your progress, save it to the HighScore and take you back to the main menu. Where you can restart and try to beat your high score.

- If you choose High Scores youll be taken to a screen that shows your high scores.

- If you choose Instructions youll be taken to a screen that shows you how to play the game. 

- If you choose Quit the game will close.

-------------The Game END----------------



It will consist of the following GameStates:
MenuState
BattleState --> Play game button

??LevelUpState --> (Still unsure if i should add this because it might cause problems with having to change things in the middle of the batlle still running)??

HighScoreState--> High Scores button
InstructionsState --> instructions button
QuitState --> Quit button


MenuState will handle the its buttons (Play, Highscore, Instructions, Quit) and its background.

BattleState will handle the actual game logic and drawing of the game.

=============================================================================================================================================
BRAKE AT 13:37 || BACK AT 16:46
=============================================================================================================================================

Im going to make everything bit by bit. Today ill make the MenuState with its buttons and background.

-------------17:02----------------
I have come to a sligth stop because there is something i dont quite understand about why the gamestates are updated and drawn in Game1 instead of just in GameElements class which to me seems way more sensible.

-?- My first assuption was that its because if i update them in the GameElements and then call the update method in Game1 like this 


        protected override void Update(GameTime gameTime)
        {
            // Escape key exits the game
            if (GamePad.GetState(PlayerIndex.One).Buttons.Back == ButtonState.Pressed || Keyboard.GetState().IsKeyDown(Keys.Escape))
                Exit();

            GameElements.Update[Whatever state](gameTime);

            base.Update(gameTime);
        }

That it would be inneficient because its updating all the gamestates even if they are not active. But then i realized that i could just put that same swich case statment into GameElements something like this:

            switch (GameState)
            {
                case Menu:
                    Menu_UpdateGE(gameTime);
                    break;

                case Play:
                    Play_UpdateGE(gameTime);
                    break;

                case Instructions:
                    Intstructions_Update(gameTime);
                    break;

                case HighScore:
                    HighScore_UpdateGE(gameTime);
                    break;

                case Quit:
                    this.Exit();
                    break;
            }
        }


And make a single Main_Update method in GameElements that would only update the active gamestate and place that into GameElements like this.

        protected override void Update(GameTime gameTime)
        {
            // Escape key exits the game
            if (GamePad.GetState(PlayerIndex.One).Buttons.Back == ButtonState.Pressed || Keyboard.GetState().IsKeyDown(Keys.Escape))
                Exit();

            GameElements.Main_Update(gameTime);

            base.Update(gameTime);
        }

Then it would only update the active gamestate. So im not sure why its done the way it is in Spaceshooter. But ill go research it and try and find an aswer.

=============================================================================================================================================
REASERCH AT 17:16 || BACK AT 17:28
=============================================================================================================================================

I looked into it and found no real reason why its done that way in Spaceshooter. So im going to go ahead and implement the gamestates update and draw methods into GameElements instead of Game1.

The main reason against it is that i lose controll over "handling framework-specific operations like Exit()"
But i have already stumbled onto a solution for that by just calling Environment.Exit(0) via my Button class in a previous version of this project.

So im going to go ahead and implement it that way.


-------------17:36----------------

Ive found another ting that id dont fully understand yet. Its about how the GameStates are defined. On a previous project i made i defined the gamestates as const ints like this:

        public const int MENU = 0, LvlSelect = 1, BtlGround1 = 2, BtlGround2 = 3, BtlGround3 = 4, BtlGround4 = 5, HIGHSCORE = 6;
        private int gameState = MENU; // Current game state


While in Spaceshooter they are defined as an enum like this:

        public enum State { Menu, Run, HighScore, Quit };
        public static State currentState;

=============================================================================================================================================
REASERCH AT 17:44 || BACK AT 17:51
=============================================================================================================================================

After looking into it i found that using an enum is the better way to go about it. 
Primarily because of:

"Type Safety" meaning that you cant assign any random int value 
to the gameState variable. You can only assign the values defined in the enum.

"Better tooling support" mainly mentioning (IntelliSense, refactoring) meaning that when you type gameState. the IDE will show you the possible values from the enum.

"Standard practice in professional C# game development" Meaning that its the more commonly used method in the industry. Making me look more professional.

So im going to go ahead and implement the gamestates as an enum instead of const ints.


-------------18:11----------------

Ive implemented the gamestates as an enum and moved the update and draw methods to GameElements.

-------------19:31----------------

Ive come to a crossroad. I have two choices on how i want to load my button textures. this is the main one that im thinking about:

        `[up in the void]`
        private static Texture2D _menuStartTexture;



        public static void LoadContentGE(ContentManager contentManager, GameWindow window)
        {
            _menuStartTexture = contentManager.Load<Texture2D>("images/Menu/start");
        }

        public static State Menu_UpdateGE(GameTime gameTime)
        {
            Button playButton = new Button(_menuStartTexture, 640 - 100, 100, 200, 50, () => currentState = State.Play, Color.White, Color.Green);
        }

and then draw it like normal. But this makes it so that ill have to make all my buttons as static variables up in the void. Making things look crouded and messy. And i have anopther
option that is a little worse but simpler and shorter:

        public static void LoadContentGE(ContentManager contentManager, GameWindow window)
        {
            content = contentManager;
        }


but in turn makes it a little worse due to these reasons as noted by AI:

•	Static state: Makes testing harder and can cause issues if you ever need multiple game instances
•	Tight coupling: GameElements now depends on ContentManager existing globally
•	Thread safety: Not thread-safe if accessed from multiple threads (unlikely in XNA games, but still worth noting) 

So i think im going to go with the first option even if it makes things a little messier.


-------------19:44----------------

Ok im a little annoyed because i cant draw it now and i think i have to move everything back up to loadcontent in GameElemnts because i cant access the button. I wanted to have everything well spread out
but i guess ill have to put all the button definitions up in the void. and also make the LoadContentGE method a little bigger. But oh well.

-------------20:20----------------

w wrote this code:
        public static Button buttons;
        public static Button playButton;


        public static void LoadContentGE(ContentManager contentManager, GameWindow window)
        {
            playButton = new Button(contentManager.Load<Texture2D>("images/menu/start"), 640 - 200 / 2, 100, 200, 50, () => currentState = State.Play, Color.White, Color.Green);
        }


        public static State Menu_UpdateGE(GameTime gameTime)
        {
            MouseState mouse = Mouse.GetState();
            playButton.Update(mouse);

            // Menu update logic for game elements can be added here
            Debug.WriteLine("In Menu Update GE");
            return State.Menu;
        }



        public static void Menu_DrawGE(SpriteBatch spriteBatch)
        {
            playButton.Draw(spriteBatch);
            // Drawing logic for game elements can be added here
        }


Then i asked AI if there was any issues with the code and it said:

Summary of Issues
1.	❌ Unused variables (menuButtons list, buttons field)  -- Ignore this/I was half way through implementing a button list
2.	❌ Not scalable (individual button fields instead of collections) 

3.	❌ Inconsistent return types (State vs void) -- I tride to make it resemble the one that we had in Spaceshooter but i guess im not supposed to anymore.
I just tested removeing all the "public static State" and made it "public static void" and it didnt seem to effect anything:

4.	⚠️ Magic numbers (hardcoded coordinates) -- 640 - 200 / 2, 100, 200, 50 i sued these to position my buttons but i could use variables instead to make it cleaner.

5.	⚠️ No centralized button management per state -- As i mentiond i was half way through implementing a button list to manage all buttons in a single collection.
So as for now everything looks like it can easily be perfectly optimized.

-------------20:45----------------

Actually ive decided to keep the magic numvbers for now because its easier to visualize where the buttons will be placed on the screen. and also i 
have no clue how to do it without clogging up the code and making it messy. So ill keep it like this for now.

-------------21:21----------------

Im ending it here for today. Ive implemented the MenuState with all working buttons that take you to the seperate gamestates. Im a little nervouse about
the lack of classes, inheritence and polymorphism but i think ill be able to fix that when i start implementing the BattleState.
Because thats where most of the game logic will be. alongside the card system that ill have to implement. 

Im honsetly really scared about the fact that grade wise this is not going to be the most impressive project. 
But im going to try my best to make it as good as possible ot add classes and stuff where i can. Without making things stupid.

___TOMORROW___
Ill have to implement the background for all the GameStates and if i have time i migth throw in and fix Highscore since its already premade for us.






02/02/26  -  17:39

Im gonna impliment the background for all the gamestates today and if i have time ill fix highscore. 

Im going to start by taking in all the stuff from my other project GameGameGame that i understand and try and implimenty it here but have only the logic in background
and loading, drawing and updating in GameElements since thats what we did in SpaceShooter.


-------------18:04----------------

Ive asked AI why its better to have the loading, updating and drawing in GameElements instead of in each gamestate class and then got the asnwer i was expecting but also
i asked it about the code that i used prevoiusly:

using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework.Graphics;
using System;

namespace GameGameGame
{
    /// <summary>
    /// Loads and displays backgrounds for different game states
    /// 
    /// Supports both animated and static backgrounds - automatically loads the right textures when the game state changes
    /// </summary>
    internal class Backgrounds : Objects
    {
        //initializes what its gonna use
        private ContentManager content;
        private GameWindow window;


        // Used to detect when game state changes so we can reload textures
        private int currentGameState = -1; // Start with an invalid value




        public Backgrounds(ContentManager content, GameWindow window) : base()
        {
            this.content = content;
            this.window = window;
            this.destinationRectangle = new Rectangle(0, 0, window.ClientBounds.Width, window.ClientBounds.Height);
        }





        public void UpdateWithState(GameTime gameTime, int gameState)
        {
            // If we switched to a different game state, load new textures
            if (gameState != currentGameState)
            {
                LoadTexturesForState(gameState);
                currentGameState = gameState;
                ResetAnimation();
            }

            // Update size in case window was resized
            destinationRectangle = new Rectangle(0, 0, window.ClientBounds.Width, window.ClientBounds.Height);

            base.Update(gameTime);
        }





        // Load the right background textures for each game state
        private void LoadTexturesForState(int state)
        {
            if (state == GameStateManager.MENU)
            {
                textures = new Texture2D[]
                {
                    content.Load<Texture2D>("images/Menu/bg1"),
                    content.Load<Texture2D>("images/Menu/bg2"),
                    content.Load<Texture2D>("images/Menu/bg3")
                };
            }


            else if (state == GameStateManager.LvlSelect)
            {
                textures = new Texture2D[]
                {
                    content.Load<Texture2D>("images/LvlSelect/Map")
                };
            }


            else if (state == GameStateManager.BtlGround1)
            {
                textures = new Texture2D[]
                {
                    content.Load<Texture2D>("images/BattleGroundSprites/BattleGround1/Battleground_BG1")
                };
            }


            else if (state == GameStateManager.BtlGround2)
            {
                textures = new Texture2D[]
                {
                    content.Load<Texture2D>("images/BattleGroundSprites/BattleGround2/Reze")
                };
            }


            else if (state == GameStateManager.BtlGround3)
            {
                textures = new Texture2D[]
                {
                    content.Load<Texture2D>("images/BattleGrounds/BattleGround3/bg1")
                };
            }


            else if (state == GameStateManager.BtlGround4)
            {
                textures = new Texture2D[]
                {
                    content.Load<Texture2D>("images/BattleGrounds/BattleGround4/bg1")
                };
            }


            else if (state == GameStateManager.HIGHSCORE)
            {
                textures = new Texture2D[]
                {
                    content.Load<Texture2D>("images/HighScore/bg1")
                };
            }
        }
    }
}


It said that it was basically doing too much as a class and braking the single responsibility principle by:

Managing texture loading/unloading (content management)
Handling game state changes
Animation logic (implied by ResetAnimation())
Window resizing
It's essentially a mini-game-manager for backgrounds


It also has memory leaks because everytime i swich gamestates i create a new array of textures 
without disposing the old ones even though its cached even though the same asset won't be reloaded from disk.
So im keeping old useless textures in memory that i dont need anymore.


Its also tightly coupled to the GameStateManager because it directly references game state constants, making it inflexible and it suggseted 
that what if i want to:

Use the same background for multiple states?
Randomly select from multiple backgrounds for a state?
Dynamically load backgrounds based on player progression?

Which i do want to do a little bit of, mainly that i want to randomly select from multiple backgrounds for a state.


And it also gave me a few suggestions on how to do it better, and the one that caugth my eye was this one with JSON-Based:

        // backgrounds.json
        [
          {
            "id": "main_menu",
            "textures": ["images/Menu/bg1", "images/Menu/bg2", "images/Menu/bg3"],
            "animationSpeed": 0.5,
            "states": [0]  // GameStateManager.MENU
          },
          {
            "id": "battle_ground_1", 
            "textures": ["images/BattleGroundSprites/BattleGround1/Battleground_BG1"],
            "states": [2]  // GameStateManager.BtlGround1
          }
        ]

It looks interesting since ive never used it before and its also said to be the most professional way to do it. So im going to try and implement it that way.

AI says its basically better in every way other than it adds some complexity by requiring JSON parsing and data management and also is sligthly slower. 
But i think its worth it.

I stumbled across this video that shows how to implement JSON to save and load stats and stuff which i migth use:
https://www.youtube.com/watch?v=gYksT0d_xLM 


This video is what shows me how to use JSON:
https://www.youtube.com/watch?v=iiADhChRriM&t=170s
Its in java script but it still helped me understand what JSON is and how to build it.

This video shows how to practuiacally use it in monogame C# at about 1 hour and 10 muinets in the video:
https://www.youtube.com/watch?v=fdbGz20q8yk  (Timestamp: 1:10:18) 


=============================================================================================================================================
BRAKE AT 19:55 || BACK AT 21:10
=============================================================================================================================================

Ok before i took the brake i looked into JSON and found out that using record is just better apperantly
but again i have almost no clue how to use it. and when i asked AI to clerify it i didnt understand it any better.

But what im worried about is the upgrade menu or the chaning of anything in the middle of the battle.
Like a new background for a new wave or something. But its so private almost annoyinly so that i cant 
figure out how to do it.

https://www.youtube.com/watch?v=NsLXQQAsYSk

This video dose a grate job on explaining records and how to use it. It also somewhat putts my mind at ease 
about using it for my backgrounds. because my backgound images are in an array and from what i understand 
by using the "with" keyword i can just change the array to a new one with new images whenever i want.
And i think ill also be able to replace it with any random background if i set it up right. with a randomizer.


-------------23:01----------------

Im tired and realized that im not going to be able to implement JSON at all since its so stupidly complex
for me to understand right now. So ill just go and do it the normal boring blocky way that i understand.

and its made for long term projects so its not really suited for a small project like this anyway.

-------------23:13----------------
I was looking at ways to make the code that i showed on line 285-404 more efficeint and just better in general
and came across Dictionary. The AI suggested this as an example

public class BackgroundDefinition
{
    public string[] TexturePaths { get; set; }
    public bool IsAnimated { get; set; }
    public float FrameDuration { get; set; } = 0.1f;
}

// In your main game class or a config loader:
private Dictionary<int, BackgroundDefinition> _backgroundDefinitions;

private void LoadBackgroundDefinitions()
{
    _backgroundDefinitions = new Dictionary<int, BackgroundDefinition>
    {
        { 
            GameStateManager.MENU, 
            new BackgroundDefinition 
            { 
                TexturePaths = new[] { "images/Menu/bg1", "images/Menu/bg2", "images/Menu/bg3" },
                IsAnimated = true,
                FrameDuration = 0.15f
            }
        },
        {
            GameStateManager.LvlSelect,
            new BackgroundDefinition
            {
                TexturePaths = new[] { "images/LvlSelect/Map" },
                IsAnimated = false
            }
        }
        // ... etc
    };
}


And as understand it, its just an inventory you can go in and out of whenever ou want

-------------00:47----------------

Done with the backgrounds im a bit pissed off about how long it took me to implement them in an effective manner as well as 
the amount of research i wasted reading about JSON and records.

My main goal was acheeved tho so im happy about that.

___TOMORROW___
Ill begin on the instructions state and highscore state, and set the ground for possibele currency and upgrade systems in the battlestate. If  i
end up on the optimistic side tomorrow.





03/02/26  -  20:19

So the moment i went back to double chak what i did recently with the backgrounds i realized that i made a mistake.
But i managed to fix it quickly enough.

Also realised that i made another mistake i think. regardless of what is going on the classes are never supposed to holds the logic for it
like:

background = new Background(content.Load<Texture2D>("images/Menu/background"), window);
or loading assests wisch is a mistake so even if it will look ugly i think ill have to put it into GameElements


New problem. i just checked stackoverflow and found out that havin a "God Class" That dose everything is a bad idea. And what
we did in Spaceshooter is exactly that. When i asked AI about it it said that its basically and organised mess and teaches you to be a bad
programmer.

Now im realliy stessing because i wnat ot do it well instead of just rushing through it and making a mess. But im very time limited Right now.


Im way too deep into this project to start over so now im low key pissed because why teach us this if its bad practice.
very very bad practice.

But im way too deep into this project to start over so now which makes me even angryer.

So now ill just have to keep going and try and make it as good as possible.


-------------21:24----------------
So now ill just follow the example left by spaceshooter and try and make it as good as possible. by continuing to move all the information 
about positions into GameElements and just have the classes hold the logic for now.


I realized that i need to plan out my ClassStructure before i start implimenting anything else. Because i have no clue how im going to 
impliment them properly without making things difficult later on


Ive made GameObjects and it will have the absolute most base things that every class that comes after will have:

- Texture
- Position


-------------21:50----------------
Actually ill come back to this later. Its late and im tired. So ill just do the simpler Instructions and Highscore states now.



-------------00:02----------------
Ive implemented the InstructionsState and HighScoreState with working backgrounds and buttons to go back to the menu. And its all fuunctioning correctly.

Though i cant say im verry happy with the God Class still. Among the other things like the lack of inheritence and polymorphism. 
But ill try and fix that when i start implementing the BattleState becasuse there is not yet much to inherit from or polymorph.

And i still dont understand why you have to start a compleatly new state to do the writing and stuff for highscore. 
And im also aware that this code is probably horribley oprimized but i genuinely have no time to fix it now. I know im starting 
instences of stuff that i never use again and stuff like that. And i think the backgrounds are probaly loaded multiple times even if they are the same.

but i have no time to fix it and no clue where to start. So ill just leave it as is. 

___TOMORROW___
Ill start with designing the class and inheritence structure for the Play and the card system. If i have time ill start implementing it as well.
But i have to remember 
good programming is 90% planning and 10% actual coding. So ill take my time to plan it out properly.



06/02/26 -  18:11

Bad news 

ive wasted 3 days doing nothing meaningful.



12/02/26 - 22:20
Bad bad bad 
Im back again a week later and i have done nothing.

But ive come up with a very simple way to implement the battle state and the card system without making things too complex or messy.

Basically the buttons allow me to make an action when i click on them. 
So i can just make a button for each card and then when i click on the card it will do the action of the card.

Ill have them in a list and then when i click on the card the one that i click on will do its action and then be 
removed from the hand and replaced with a new random card from the card assortment.

Its definitely
easier said than done because i have no clue how to actually make
the cards do damage other than just putting a DamageEnemy() method in
the action part and hoping that works. But i have a feeling that it wont be that simple but i think its still possible to acheeve it
and get it done in time.

___TOMORROW___
Tell Tatiana that i have decided to kinda restart ish with this
Check in with her about the new plan and see if she is ok with it
Start with the card system and try to get a basic version of it working with just one card and then build from there.

^^^^T-8 days until the D-day^^^^

________________________

Actually i have a hard time going to sleep not knowing if its going to work so im going to try and start with the card system tonight and see if i can get a basic version of it working.

First ill make tbe background for the battleground and then ill make class Card inherits from Button and then make a list of names with the things cards do. 
No i need to make an array in order to pull out random cards from it and add a swich case for each card to define it as the new thing that it is supposed to do.

-------------23:24-------------
It works. it works just as i imagined it would. I can click on the card and it does the action of the card now ill take some time to find a way to make it randomly 
generate a new card after i click on it and then ill add more cards to the card pool and make them do different things.

My plan is to make a random number generator that generates a number between 0 and 3 because that how many cards i have ready but 
i imagie it will look sonething like this:

deck[random.Next(0, 3)]]

and do that 3 times...
im almost certain it will not work but better try it just in case im a genious and just rigth.

damn. i just realized that the cards are set to a fixed position so even if it works if i happen to get 2 attack cards theyll be ontop of eachotehr not next to each other. 
meaning i could make a new 3 deck one for each card slot and then when i click on the card it will pull a random card from the card pool and put it in the slot that i clicked on.

-------------23:46-------------
Well the good news is that it works as inteded, perhaps even a litte too well because all the cards are shuffling between themselves 
like 100 times every second.
And i have no idea how to solve it. 

I imagine that i have to make a seperate class that only updates the random part whenever i click on the card.
so i have to make a class that i can put into the buttons action part and that should.

Like this here
https://stackoverflow.com/questions/11430683/save-generated-random-numbers-for-later-use 

-------------00:06-------------
Well that failed and i dont really want to do it like that anyway since it will be annoying to deal with. the issue is that it updates once every time there is an update in the game. i need to make something random and capture that in a variable 
and then only update that variable when i click on the card. but i have no clue how to do that.

when i asked AI for ideas it said i could try adding this  

randomCardGen = new Random();
pos_Index = randomCardGen.Next(2);


because what its supposed to do is save it as a static int variable and then i can reddefine it whenever i click on the card buutton by
pos_Index = randomCardGen.Next(pos_.Length);*

and make the draw and update method use the pos_Index variable instead of the random generator itself.
Im a bit sceptical about it still. Because i dont really understand why it saves it only once as a pos_Index and then only changes it when i click on the card.
But ill put it in anyway.

-------------00:28-------------
Just like that it works. I have no clue how but it works. but since i used AI and im writing about it i feel like i have a responsibility to understand it. 
so im going to try and spend a bit of time trying to understand how it works. and then explain it here.

Ok so as i understand it, the randomCardGen is still constantly generating random numbers but what pos_Index
is doing is capturing a random moment in the generator and defining itself as that and by putting the index in the array instead makes it a single card

and when we put the pos_Index = randomCardGen.Next(pos_.Length); in the action part of the card button it redefines the pos_Index as a new random number 
from the gerator for just a moment when you releace the card button because thats how the button is made. it only captures the update on the moment of releace

it makes a lot of sense now that i think about it. its actually really smart and simple. and it works perfectly. so im really happy about that.

What i am still a litte bit scared about is how this will look like in terms of a grade. because i know that the code 
is not the best and the new methods are far too long and not very well optimized. 

BUT ALAS ITS THE END OF MY ENERGY SO IM GOING TO END IT HERE FOR TODAY. so hereis the official agenda for tomorrow:

___TOMORROW___
Tell Tatiana that i have decided to kinda restart ish with this
Check in with her about the new plan and see if she is ok with it

Start with the enemy that just takes damage. Using my multiple other game examples as refrences







13/02/26 - 08:32
So i just presented my thing and eerything seems preatty good to go with her.

I think im going to start with the TurnSystem here in school and the Enemy class later tonigth. 
Im still a bit sceptical when it comes to the card system because i have to also put in a select enemy system
but we can start small.

first we make a turn system inspired by my older gameProject and try to explain it better and then in that we make
an enemy and then finally we make multiple enemies and a select system.

first i need to make something that stores the turns so i can add another thing into the card 
ststem that adds one to the turn counter every time i click on it and then when the turn 
counter.

I did this so far
===============
CODE
===============
       int Turncounter;
        protected Action DidSomething;
        protected bool PlayerTurn = false;
        private bool CardEnabled = true;
        private float TurnTimer = 3f;

        public TurnLogic(int turnCounter)
        {
            Turncounter =  turnCounter;
        }

        public void StartTurn(GameTime gameTime)
        {
            PlayerTurn = true;
            CardEnabled = true;
            if (PlayerTurn)
            {
                Console.WriteLine("Player's turn");

            }
        }

        public void PlayerTurnOver(GameTime gameTime)
        {
            Console.WriteLine("Player's turn is over \n");
            Console.WriteLine("Enemy's turn");

            if (TurnTimer != 0)
            {
                TurnTimer = TurnTimer - (float)gameTime.ElapsedGameTime.TotalSeconds;
            }

            PlayerTurn = false;
            CardEnabled = false;
            Turncounter++;

            StartTurn(gameTime);

            Debug.WriteLine($"{Turncounter}");
        }

===============
CODE END
===============

And it dosesnt work really wll because the timer dosent work properly and it just spams the console with "Enemy's turn"
so ill take my time fixing it at home later today.

-------------09:22-------------





14/02/26 - 20:37
Bad news. Yesterday i was ment to finish the turn system and make a basic enemy class but i decided to enjoy myself by not doing anything. Now i have twice as much on my shoulders
and i have even less time to do it.

regardless ill starty looking for ideas on a turn system and ways to improve class stucture.

Ive fixed my current class stucture basing it all of of pressable objects as the base for everything
Sadly i cant put in images here but i made a file where you can see everything. 

IN THE FILE PlanImages:

A Photo called:
""Basic Structure""

-------------22:01-------------
Im stuggeling to think of what the card field should have in it to make it different from the button class.
Rigth now this is what a card looks like:
new Card("DamageCard", content.Load<Texture2D>("images/Cards/DmgCard"), 600, 100, 80, 120, () =>{ EnemyHP -= 10; pos2Index = randomCardGen.Next(pos2.Length); Debug.WriteLine("DmgCardPressed");}, Color.White, Color.Red),

Im thinking maybe i make a public virtual void OnClick() method and override it in the card class and make it do something depenting on the name so i dont have to type it out every time.
instead i can just write something like:
new Card("DamageCard", content.Load<Texture2D>("images/Cards/DmgCard"), 600, 100, 80, 120, () => OnAction, Color.White, Color.Red),
and it will understand directly that all it has to do is just do the damage action without me having to write it out every time.


-------------00:47-------------
Good news i managed to lock in and revamp alot of the class structure and make it alot more professional with way more inheritence and polymorphism.
Without braking anything major. 
On the other hand i havent done anyting new other than add an CombatEntity class that has other enemy classes like EnemyBrawler and i managed to make it so that
he has a 70% chance of damaging and a 30% chanse of healing. This will be changed for all the other enemys as well of course like the healer is obveiously going to heal more 
than he is attack.

but i think things went preatty decenty for the past few hours. Now i have even more work on my shoulders. but that is a problem for future me to deal with.
fuck that guy am i rigth. regardless i still have quite a bit to revamp but it should be done by tomorrow. As for the rest of the day ill spend it waching the
holy grail, the best show ive seen in a very long time Oshi No Ko or My Star in english


___TOMORROW___
Finish the revamp 
Move on to the Turn system
And see what else you can do.







15/02/26 - 19:49
Ok im starting or more accuretly continuing on the restructuring of the classes. As for the show that i watched yesterday, it was one of the weaker episodes 
with a bigger focuise on character development. 
I would give it a 6/10.
Next one comes out on wendsday.

Regardless Enough idle chatter BACK TO WORK.

Let me explain what im trying to do with the card class. i want to basically have it be a button with a name that defines what it is and then have an OnClick 
method that first makes it so that you have to select an enemy before the card dose anything and then after you select the enemy it does 
the action depending on the card name. 
EX:

if (name == damageCard)
{
    EnemyHP -= 10;
}

else if (name == HealCard)
{
    PlayerHP += 10;
}

else if (name == BuffCard)
{
    PlayerAttack += 5;
}
and so on

Im doing this to make the card code a little shorter and cleaner because rigth now it looks like this:
            pos3 = new Card[]
            {
                new Card("DamageCard", content.Load<Texture2D>("images/Cards/DmgCard"), 900, 100, 80, 120, () =>{ EnemyHP -= 10; pos3Index = randomCardGen.Next(pos3.Length); Debug.WriteLine("DmgCardPressed");}, Color.White, Color.Red),
                new Card("HealCard", content.Load<Texture2D>("images/Cards/HealCard"), 900, 100, 80, 120, () => { PlayerHP += 10; pos3Index = randomCardGen.Next(pos3.Length); Debug.WriteLine("HealCardPressed");}, Color.White, Color.Green)
            };

i want to make it like this

            pos3 = new Card[]
            {
                new Card("DamageCard", content.Load<Texture2D>("images/Cards/DmgCard"), 900, 100, 80, 120, Color.White, Color.Red),
                new Card("HealCard", content.Load<Texture2D>("images/Cards/HealCard"), 900, 100, 80, 120, Color.White, Color.Green)
            };


which i think would make it way more sucure and cleaner in general, But that mean i have to remove the action part from the base Clickable class. i wonder if i can eved do this for
the card colors as well. like make it so that the card colors are defined by the name as well making it:

                new Card("HealCard", content.Load<Texture2D>("images/Cards/HealCard"), 900, 100, 80, 120)



-------------00:02-------------


Ok new plan. Lets forget everything because ive sat here for damn near 4 hours trying to figure out
how to make the card class better and i just cant do it. 
I have no clue how to make it so that the card action is defined by the name without making a complete mess of the code and making it really hard to work with.

-------------03:48-------------
This is not a joke i reapeat this is not a joke. though i really wish it was i got a litte hyperfocused and couldnt stop until
i had at least something working and fuck me i kinda got it working.

i managed to get the card system to make it so that if you press a card it waits until youve pressed an enemy in order to execute the cards supposed action 
but only lord knows if that shit actually works or not i have a feeling that it dosent.

Of course it dosent fucking function so back to the the good ol wip and the chain.

You know what i give up on having most of the damage logic in the actual classes. that is way too annoying and difficult. ill just place it in gameElements. 
better yet ill make a seperate class called battleLogic and use that as a blanck slate to build the thing by my self

Im going to ise one of my older codes as a basis wich had this;

        public enum TurnState
        {
            PlayerTurn,       
            SelectingTarget,  
            EnemyTurn,        
            WaveCleared,      
            BattleOver        
        }

It treats every part of it like a state and i can do states, because i actually understand them and they are clear as can be.

-------------05:18-------------
ive somehow managed to take 5 steps back. im a little retarded so i think i migth actually just rewind it completely to 
before i fuck up somethinge esle
Enougth for today.

ive hardReverted everything back to what i had yesterday and i plan on not repeating the same stupid mistakes. 

IF IT AINT BROKEN DONT FIX IT

I hope ill pull some ungodly lock in to get this done in any case See ya tomorrow

___TOMORROW___
Dont be a faliour
gergergergergger1





16/02/26 - 16:02
Im finally a succsess 

look at me mom im a succsess

-------------20:49-------------
Ok Grate news

I got a very rudementry version of a turnloop finctioning in GameElements. i admit its definitly not the most striking code on earth and i know it
and im not neccicerily proud of it but compared to when i wasted hours on something that dosent even function, this is one hell of a step up.

this is what it looks like rigth now:

===============
CODE
===============

       public static void Play_UpdateGE(GameTime gameTime)
        {
            //--------------------------------CardSystem--------------------------------//
            MouseState mouse = Mouse.GetState();

            bool EnemyClicked = true;


            switch (currentPlayPhase)
            {
                case PlayPhase.SelectCard:
                    pos1[pos1Index].Update(mouse);
                    pos2[pos2Index].Update(mouse);
                    pos3[pos3Index].Update(mouse);

                    selectedCard = null;

                    if (pos1[pos1Index].selectableCard)
                    {
                        selectedCard = pos1[pos1Index];
                    }
                    else if (pos2[pos2Index].selectableCard)
                    {
                        selectedCard = pos2[pos2Index];
                    }
                    else if (pos3[pos3Index].selectableCard)
                    {
                        selectedCard = pos3[pos3Index];
                    }



                    if (selectedCard != null)
                    {
                        pos1[pos1Index].selectableCard = false;
                        pos2[pos2Index].selectableCard = false;
                        pos3[pos3Index].selectableCard = false;


                        if (selectedCard.target == "Self")
                        {
                            switch (selectedCard.name)
                            {
                                case "HealCard":
                                    PlayerHP += 10;
                                    break;
                            }
                            Debug.WriteLine("Self Card has been activated");

                            pos1Index = randomCardGen.Next(pos1.Length);
                            pos2Index = randomCardGen.Next(pos2.Length);
                            pos3Index = randomCardGen.Next(pos3.Length);

                            currentPlayPhase = PlayPhase.SelectCard;
                        }

                        else if (selectedCard.target == "Enemy")
                        {
                            Debug.WriteLine("CARD HAS BEED SELECTED");

                            currentPlayPhase = PlayPhase.SelectEnemy;
                        }
                    }
                    break;


                case PlayPhase.SelectEnemy:
                    //Show instructions

                        

                    if (EnemyClicked == true)
                    {
                        Debug.WriteLine("ENEMY HAS BEEN CLICKED");

                        switch (selectedCard.name)
                        {
                            case "DamageCard":
                                EnemyHP -= 10;
                                break;
                        }


                        pos1Index = randomCardGen.Next(pos1.Length);
                        pos2Index = randomCardGen.Next(pos2.Length);
                        pos3Index = randomCardGen.Next(pos3.Length);

                        selectedCard = null;

                        currentPlayPhase = PlayPhase.SelectCard;
                    }

                    break;
            }


            //--------------------------------CardSystem END--------------------------------//




            //Debug.WriteLine($"PlayPhase {currentPlayPhase}");
        }

===============
CODE END
===============

Basically what it dose is:

Sets up a null Card
Then fills it with the card that was clicked and all of its information.
========
EX:
Card selectedCard = null

//After a card is clicked

Card selectedCard = new Card("HealCard","Self", content.Load<Texture2D>("images/Cards/HealCard"), 900, 100, 80, 120, () => { pos3[pos3Index].selectableCard = true;}, Color.White, Color.Green)
========

Then i check if if its null or not and if its not its supposed to stop you from pressing the cards again by making their OnClick Action null but i havent
figured it out yet with the:

===============
CODE
===============
    pos1[pos1Index].selectableCard = false;
    pos2[pos2Index].selectableCard = false;
    pos3[pos3Index].selectableCard = false;

===============
CODE END
===============
Step by step- a lesson that took 7 hours of wasted time to learn. Regardless 

it check the terget information of the card which can eigther be "Self" or "Enemy"

if its self
It checks the name of the card to figure out what exactly its supposed to do and then dose it

then it changes the card again: Which i just realised is wrong its supposed to do that only for the selected card. ill fix it
-------------22:19-------------




-------------23:44-------------
i took a sligth brake and after i got back i tride to just add it in as an index like:

                    selectedCard = null;
                    selectedCardIndex = -1;

                    if (pos1[pos1Index].selectableCard)
                    {
                        selectedCard = pos1[pos1Index];
                        selectedCardIndex = pos1Index 
                    }

                    and then tride to do

                    selectedCardIndex = randomCardGen.Next(2);


                    but that dosent actually change the pos1,2,3Index so the card that is shown stayse the same
                    and get stuck on the first random cards so i instead decided to fix it in probably the least clean way possible


                    if (pos1[pos1Index].selectableCard)
                    {
                        selectedCard = pos1[pos1Index];
                        selectedCardIndex = 1 
                    }
                    
                    and then later down 

                    switch (selectedPosition)
                    {
                        case 1: pos1Index = randomCardGen.Next(2); break;
                        case 2: pos2Index = randomCardGen.Next(2); break;
                        case 3: pos3Index = randomCardGen.Next(2); break;
                    }


I repeat
IF IT AINT BROKE DONT FIX IT

and this certainly aint broke so let me restart the explanation


===============
CODE 
===============
         switch (currentPlayPhase)
            {
                case PlayPhase.SelectCard:
                    pos1[pos1Index].Update(mouse);
                    pos2[pos2Index].Update(mouse);
                    pos3[pos3Index].Update(mouse);





                    selectedCard = null;
                    selectedCardPos = 0;

                    if (pos1[pos1Index].selectableCard)
                    {
                        selectedCard = pos1[pos1Index];
                        selectedCardPos = 1;

                    }
                    else if (pos2[pos2Index].selectableCard)
                    {
                        selectedCard = pos2[pos2Index];
                        selectedCardPos = 2;

                    }
                    else if (pos3[pos3Index].selectableCard)
                    {
                        selectedCard = pos3[pos3Index];
                        selectedCardPos = 3;
                    }



                    if (selectedCard != null)
                    {
                        pos1[pos1Index].selectableCard = false;
                        pos2[pos2Index].selectableCard = false;
                        pos3[pos3Index].selectableCard = false;


                        if (selectedCard.target == "Self")
                        {
                            switch (selectedCard.name)
                            {
                                case "HealCard":
                                    PlayerHP += 10;
                                    break;
                            }
                            Debug.WriteLine("Self Card has been activated");

                            switch (selectedCardPos)
                            {
                                case 1: pos1Index = randomCardGen.Next(pos1.Length); break;
                                case 2: pos2Index = randomCardGen.Next(pos2.Length); break;
                                case 3: pos3Index = randomCardGen.Next(pos3.Length); break;
                            }


                            currentPlayPhase = PlayPhase.SelectCard;
                        }

                        else if (selectedCard.target == "Enemy")
                        {
                            Debug.WriteLine("CARD HAS BEED SELECTED");

                            currentPlayPhase = PlayPhase.SelectEnemy;
                        }
                    }
                    break;


                case PlayPhase.SelectEnemy:
                    //Show instructions



                    if (EnemyClicked == true)
                    {
                        Debug.WriteLine("ENEMY HAS BEEN CLICKED");

                        switch (selectedCard.name)
                        {
                            case "DamageCard":
                                EnemyHP -= 10;
                                break;
                        }


                        switch (selectedCardPos)
                        {
                            case 1: pos1Index = randomCardGen.Next(pos1.Length); break;
                            case 2: pos2Index = randomCardGen.Next(pos2.Length; break;
                            case 3: pos3Index = randomCardGen.Next(pos3.Length); break;
                        }


                        selectedCard = null;

                        currentPlayPhase = PlayPhase.SelectCard;
                    }

                    break;
            }
===============
CODE END
===============

it sets the selectedCard = null; wich is filled and redefined by the actual card

selectedCardPos = 0; which is invalid and gets changed to a valid card pos when the card is clicked

once the selectedCard is redefined it first cheks if the card is used on the self in wich case it automatically uses it, randomizes the pressed card and restarts the loop
setting everything back to null and 0

If the Target is "Enemy" Then it gose to the PlayPhase.SelectEnemy where it firts waits for you to click an enemy 

once you do, it checks what the card is supposed to do and dose it on the enemy

then Sets the chosen card to random and restarts the whole loop.




-------------00:08-------------

It functions perfectly. Ill start adding more cards later but for now ill start doing the enemys

-------------01:30-------------
Ive made a functioning enemy that dose exactly what i wanted it to do which is just randomly either attack or heal.
with a tendency to to Spesific things with a higehr chance if it is a specific type of enemy. 
like the brawler has a higher chance to attack and the healer has a higher chance to heal.

Since i dont yet feel very tired ill try and satrt with the health bars and the visual part of the battle state.

-------------03:09-------------
Im starting to get a bit tired so im going to get off

but today was a far more productive day. Because i went step by step without getting distracred. I made sure that everything happend step by step.
one thing at a time.

I managed to make The card system function with turns and stuff like that also got enemy functioning and now am working on the health bar. ive finished the class
so ill just leavbe the rest up to tomorrows me.

___TOMORROW___
Fix the health bar
Get player functioning
Add a wave mecanic
add multiple enemys







18/02/26 - 17:41

I forgot to write in the log yesterday but i managed to get the health bars working.

Today i plan on trying to efectivise things spesifically make the positions and textures. basically things that clog up the gameelements 
so ill make a new class called ObjectPosTex

-------------19:35-------------
I got that finished now all the positions and textures are stored in a neat little class and i can just call i am 
like litterally using:

using static Another_Game_Final_no_fugazy.ObjectPosTex;


I dont know if this is a good thing to do in terms of the grade and general programming but it makes my life a lot easier and 
the code a lot cleaner so im going to do it anyway.



Its Time to move onto the wave system. 

I could make life simple by putting a new method into gameElements that is like StartWave() 
and then just call it whenever i need to but that will make my gameElements look not so nice.

And i have principles and pride when it comes to the cleanliness of my gameElements 
so im going to try and make a new class called WaveManager 

YAAAAAAAAY I LOVE MAKING LIFE DIFFICULT FOR MYSELF!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


-------------20:27-------------
FOrget about that for now. I just realised that all of my enemy code is not yet ready for multiple enemys and that it will be a pain 
if i have to change it later on so im going to try and make a quick player because its preatty simple just a picure and healthbar. 
and make it work for multiple enemys right now. and then later make the wave function.

Ill mane enemymage that has a tendency to debuff the player
and a mage that has a tendency to buff itself and increase the healt of other enemys. ill probably end up making it random. but
ill first try making it so that it picks the enemy with the lowest health. Its backward and i should first make it random and then 
make it so that it picks the lowest health 

But i want it to work that way and i feel like ill get lazy and just leave it as random if 
i do it the other way around so im going to try and make it work that way from the start.


Im kinda tired right now so ill deal with most of it afer a short bralke because im lost rn


-------------21:17-------------
Altrigth back to work. I had a thougth and thought about 
how i only have effectively 2 cards heal and damage. i want to have hell a cards that do many things. like debuff and eventually even poison 
but then i need some way to display that so im going to need an effect box that shows the effects that are currently on the player and the enemys.
i can also use it to display the increases in stats per wave.


-------------00:27-------------
DONE
i have got the effectbox and player made and working also got the debuff working, no spesific card yet baut that will be easy to add later on.


its late so ill cut it off here but the rest should be pretty easy to dd.

___TOMORROW___
Get wave system working
Set up the other enemys
Set up thair positions
Get highscore working
Comments and clean up the code a bit.









19/02/26 - 17:59

Today marks D-Day where i need to finish eveything and get it ready for submission. 
I have a lot to do but i think its possible to get it done in time if i just stay focused and work step by step.

I think the smartest order in wich to do it is

-Set up the other enemys
All the infrastucutre is already there for multiple enemys so it should be pretty easy to just add them in and make them do their thing.

-Set up thair positions
Since i have multiple enemys to play deal with it will be easier to just set up the positions for them all at once 

-Get wave system working
Because once everything is ready to go only then add a wave system that just calls random enemys from the 
pool and sets thair health and stuff like that. And increases it

-Get highscore working
Tracks the wave number and then saves it in

-Comments and clean up the code a bit.
Then finally once everything is working and done, go through the code and add comments and clean it up a bit.

==============================================================================================================

Lets start with the enemys. All the effects are already there for the mage so thats effeftivly done just a copy paste of the brawler with a higher chance to
debuff the player.

The healer is a bit more difficult because i want him to be able to heal other enemys as well so i need to make it so that he can choose 
the enemy with the lowest health and heal them instead of himself

--------------19:24-------------
I noticed a small issue with the healthpbar and effectbox so i fixed that and then moved onto the enemys and got them mostly functioning
My healer dosent work perfectly yet becasue sometimes it heals nothing. i think its healing the dead enemys but im going to take a short brake 
and come back later

--------------19:49-------------

back at it


--------------21:01-------------
This was the longes time ive wasted on a single issue. the issue was thet i was calling The heal method of the combat entity class 
instead of the one in the healer class making it loop infinity because the heal method in the 
healer class calls the heal method in the combat entity class and then it just loops between the two of them until it eventually crashes because of stack overflow.


ANYWAY its fixed now and the healer works perfectly now.

--------------TODO-------------
-Set up thair positions
Since i have multiple enemys to play deal with it will be easier to just set up the positions for them all at once 

-Get wave system working
Because once everything is ready to go only then add a wave system that just calls random enemys from the 
pool and sets thair health and stuff like that. And increases it

-Get highscore working
Tracks the wave number and then saves it in

-Comments and clean up the code a bit.
Then finally once everything is working and done, go through the code and add comments and clean it up a bit.
-------------TODO--------------


NOW we set up dymnamic posiuons 

--------------21:34-------------

Spawning in random positions is finished 


-------------TODO--------------
-Get wave system working
Because once everything is ready to go only then add a wave system that just calls random enemys from the 
pool and sets thair health and stuff like that. And increases it

-Get highscore working
Tracks the wave number and then saves it in

-Comments and clean up the code a bit.
Then finally once everything is working and done, go through the code and add comments and clean it up a bit.
-------------TODO--------------

Now its onto my least favorite and probably longest part which is the wave system. 
because i weant it to also dynamically increase the difficulty by increasing the health and stuff like that of the enemys as well as 
adding more of them in later waves.

like you sart with one enemy brawler and then later on you can get 2 or 3 enemys in one wave and they can be mages and healers as well.

--------------22:47-------------
I genuanly cant think of any other way to do this other than adding another class to gameElements which i feel is discrasefull. It looks perfect rigth now
only the most required Things load update and draw but alas sometimes you need to settle and do what you have to do 
take it to the back of the barn and just end the perfect clean streak.

--------------23:52-------------
It works. not qute perfect yet but good enough for now. OK yeah its all done now.

-------------TODO--------------
-Get highscore working
Tracks the wave number and then saves it in

-Comments and clean up the code a bit.
Then finally once everything is working and done, go through the code and add comments and clean it up a bit.
-------------TODO--------------

--------------01:41-------------
Now all i have left is the comments and clean up. Which is just tedious busywork but its gotta be done. 

--------------03:39-------------
Finished the comments. not so much with the cleanup but i dont think i have enough Energy to do a full cleanup so im just going to go lighrts out now and call it a day.

